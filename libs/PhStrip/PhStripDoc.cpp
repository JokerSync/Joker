/**
 * @file
 * @copyright (C) 2012-2014 Phonations
 * @license http://www.gnu.org/licenses/gpl.html GPL version 2 or higher
 */

#include <QDomDocument>
#include <QXmlStreamWriter>

#ifdef USE_SYN6
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#endif

#include <boost/version.hpp>
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif

#include <boost/format.hpp>

#if defined(__clang__)
#pragma clang diagnostic pop
#endif
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>

#include "PhTools/PhDebug.h"
#include "PhTools/PhFileTool.h"

#include "PhStripDoc.h"

PhStripDoc::PhStripDoc() :
	_lineModel(new PhStripLineModel()),
	_cutModel(new PhStripCutModel()),
	_loopModel(new PhStripLoopModel()),
	_peopleModel(new PhStripPeopleModel()),
	_timeIn(PHTIMEMAX),
	_timeOut(PHTIMEMIN)
{
	reset();
	connect(_peopleModel, &PhStripPeopleModel::dataChanged, _lineModel, &PhStripLineModel::peopleChanged);

	connect(_lineModel, &PhStripLineModel::timeInChanged, this, &PhStripDoc::updateTimeIn);
	connect(_lineModel, &PhStripLineModel::timeOutChanged, this, &PhStripDoc::updateTimeOut);
}

PhStripDetect::PhDetectType openingDetectFromString(QString type)
{
	if (type == "in_open") {
		return PhStripDetect::MouthOpen;
	}
	else if (type == "in_close") {
		return PhStripDetect::MouthClosed;
	}
	else {
		return PhStripDetect::MouthClosed;
	}
}

QString openingDetectToString(PhStripDetect::PhDetectType type)
{
	if (type == PhStripDetect::MouthOpen) {
		return "in_open";
	}
	else if (type == PhStripDetect::MouthClosed) {
		return "in_close";
	}
	else {
		return "in_close";
	}
}

PhStripDetect::PhDetectType closingDetectFromString(QString type)
{
	if (type == "out_open") {
		return PhStripDetect::MouthOpen;
	}
	else if (type == "out_close") {
		return PhStripDetect::MouthClosed;
	}
	else {
		return PhStripDetect::MouthClosed;
	}
}

QString closingDetectToString(PhStripDetect::PhDetectType type)
{
	if (type == PhStripDetect::MouthOpen) {
		return "out_open";
	}
	else if (type == PhStripDetect::MouthClosed) {
		return "out_close";
	}
	else {
		return "out_close";
	}
}

PhStripDetect::PhDetectType innerDetectFromString(QString type)
{
	if (type == "mpb") {
		return PhStripDetect::Labial;
	}
	else if (type == "fvr") {
		return PhStripDetect::Dental;
	}
	else if (type == "neutral") {
		return PhStripDetect::Unknown;
	}
	else if (type == "a") {
		return PhStripDetect::Aperture;
	}
	else if (type == "i") {
		return PhStripDetect::SemiLabial;
	}
	else if (type == "o") {
		return PhStripDetect::Bowl;
	}
	else if (type == "weuque") {
		return PhStripDetect::Advance;
	}
	else {
		return PhStripDetect::Unknown;
	}
}

QString innerDetectToString(PhStripDetect::PhDetectType type)
{
	if (type == PhStripDetect::Labial) {
		return "mpb";
	}
	else if (type == PhStripDetect::Dental) {
		return "fvr";
	}
	else if (type == PhStripDetect::Unknown) {
		return "neutral";
	}
	else if (type == PhStripDetect::Aperture) {
		return "a";
	}
	else if (type == PhStripDetect::SemiLabial) {
		return "i";
	}
	else if (type == PhStripDetect::Bowl) {
		return "o";
	}
	else if (type == PhStripDetect::Advance) {
		return "weuque";
	}
	else {
		return "neutral";
	}
}

bool PhStripDoc::importDetXFile(QString fileName)
{
	PHDEBUG << fileName;
	if (!QFile(fileName).exists()) {
		PHDEBUG << "The file doesn't exists" << fileName;
		return false;
	}

	_filePath = fileName;

	// Opening the XML file
	QFile xmlFile(fileName);
	if(!xmlFile.open(QIODevice::ReadOnly)) {
		PHDEBUG << "Unable to open" << fileName;
		return false;
	}

	// Loading the DOM (document object model)
	QDomDocument *domDoc = new QDomDocument();
	if (!domDoc->setContent(&xmlFile)) {
		xmlFile.close();
		delete domDoc;
		PHDEBUG << "The XML document seems to be bad formed " << fileName;
		return false;
	}

	reset();

	QDomElement detX = domDoc->documentElement();

	if(detX.tagName() != "detx") {
		xmlFile.close();
		delete domDoc;
		PHDEBUG << "Bad root element :" << detX.tagName();
		return false;
	}

	_generator = "Cappella";
	//With DetX files, fps generated by Cappella is always 25 no drop
	_videoTimeCodeType = PhTimeCodeType25;

	// Reading the header
	if(detX.elementsByTagName("header").count()) {
		QDomElement header = detX.elementsByTagName("header").at(0).toElement();

		// Read the Cappella version
		if(header.elementsByTagName("cappella").count())
			_generator += " v" + detX.elementsByTagName("cappella").at(0).toElement().attribute("version");

		// Reading the title
		if(header.elementsByTagName("title").count())
			_title = header.elementsByTagName("title").at(0).toElement().text();
		else
			_title = QFileInfo(fileName).baseName();

		// Reading the translated title
		if(header.elementsByTagName("title2").count())
			_translatedTitle = header.elementsByTagName("title2").at(0).toElement().text();

		// Reading the episode info
		if(header.elementsByTagName("episode").count()) {
			QDomElement episodeElem = header.elementsByTagName("episode").at(0).toElement();
			_episode = episodeElem.attribute("number");
			_season = episodeElem.attribute("season");
		}

		// Reading the video path
		if(header.elementsByTagName("videofile").count()) {
			QDomElement videoFile = header.elementsByTagName("videofile").at(0).toElement();
			_videoPath = videoFile.text();
			// Reading the video time in
			_videoTimeCodeType = PhTimeCode::computeTimeCodeType(videoFile.attribute("tctype").toDouble());
			_videoTimeIn = PhTimeCode::timeFromString(videoFile.attribute("timestamp"), _videoTimeCodeType);
			_videoForceRatio169 = videoFile.attribute("forceRatio169") == "true";
		}

		// Reading the last position
		if(header.elementsByTagName("last_position").count()) {
			QDomElement lastPosition = header.elementsByTagName("last_position").at(0).toElement();
			_lastTime = PhTimeCode::timeFromString(lastPosition.attribute("timecode"), _videoTimeCodeType);
		}

		// Reading the author name
		if(header.elementsByTagName("author").count()) {
			QDomElement author = header.elementsByTagName("author").at(0).toElement();
			_authorName = author.attribute("firstname") + " " + author.attribute("name");
		}

		// Reading other meta informations
		if(header.elementsByTagName("production").count()) {
			QDomElement production = header.elementsByTagName("production").at(0).toElement();
			_metaInformation["Producteur"] = production.attribute("producer");
			_metaInformation["Année de production"] = production.attribute("year");
			_metaInformation["Distributeur"] = production.attribute("distributor");
			_metaInformation["Réalisateur"] = production.attribute("director");
			_metaInformation["Diffuseur"] = production.attribute("diffuser");
			_metaInformation["Pays d'origine"] = production.attribute("country");
		}
	}

	QMap<QString, PhPeople*> peopleMap;

	// Reading the "role" lists
	if(detX.elementsByTagName("roles").count()) {
		QDomElement roles = detX.elementsByTagName("roles").at(0).toElement();
		QDomNodeList roleList = roles.elementsByTagName("role");
		for (int i = 0; i < roleList.length(); i++) {
			QDomElement role = roleList.at(i).toElement();
			PhPeople *people = new PhPeople(role.attribute("name"), role.attribute("color"));
			this->addPeople(people);

			//Currently using id as key instead of name
			QString id = role.attribute("id");
			if(id.isEmpty()) {
				PHDEBUG << "empty id";
				reset();
				return false;
			}

			peopleMap[id] = people;

			// Reading picture
			if(role.elementsByTagName("image").count() != 0) {
				QDomElement image = role.elementsByTagName("image").at(0).toElement();
				people->setPicture(image.text());
			}
		}
	}

	int loopNumber = 1;

	// Reading the strip body
	if(detX.elementsByTagName("body").count()) {
		QDomElement body = detX.elementsByTagName("body").at(0).toElement();
		for(int i = 0; i < body.childNodes().length(); i++) {
			if(body.childNodes().at(i).isElement()) {
				QDomElement elem = body.childNodes().at(i).toElement();

				PhTime timeIn = PhTimeCode::timeFromString(elem.attribute("timecode"), _videoTimeCodeType);
				// Reading loops
				if(elem.tagName() == "loop")
					this->addLoop(new PhStripLoop(timeIn, QString::number(loopNumber++)));
				// Reading cuts
				else if(elem.tagName() == "shot")
					this->addCut(new PhStripCut(timeIn, PhStripCut::Simple));
				else if(elem.tagName() == "line") {
					timeIn = -1;
					PhTime lastTime = -1;
					PhTime lastLinkedTime = -1;
					PhPeople *people = peopleMap[elem.attribute("role")];
					float y = elem.attribute("track").toInt() / 4.0;
					QString currentText = "";
					PhStripLine *line;

					for(int j = 0; j < elem.childNodes().length(); j++) {
						if(elem.childNodes().at(j).isElement()) {
							QDomElement lineElem = elem.childNodes().at(j).toElement();
							if(lineElem.tagName() == "lipsync") {							
								PhTime linkTime = PhTimeCode::timeFromString(lineElem.attribute("timecode"), _videoTimeCodeType);

								if(timeIn < 0) {
									timeIn = linkTime;
									lastTime = linkTime;
									line = new PhStripLine(timeIn, openingDetectFromString(lineElem.attribute("type")), people, y, 0.25f);
									continue;
								}

								if(lineElem.attribute("link") != "off") {
									PhTime duration = linkTime - lastTime;

									PhStripDetect::PhDetectType type;
									if (j == elem.childNodes().length() - 1)
									{
										type = closingDetectFromString(lineElem.attribute("type"));
									}
									else {
										type = innerDetectFromString(lineElem.attribute("type"));
									}

									PhStripText *text = new PhStripText(currentText, duration, type);
									line->append(text);
									lastTime = linkTime;
									currentText = "";
									lastLinkedTime = lastTime;
								}
								else {
									PhStripDetect *detect = new PhStripDetect(innerDetectFromString(lineElem.attribute("type")), linkTime - timeIn);
									line->addUnlinkedDetect(detect);
								}
							}
							else if(lineElem.tagName() == "text") {
								currentText += lineElem.text();
							}
						}
					}

					// Handling line with no lipsync out
					if(currentText != "") {
						PhTime duration = currentText.length() * 1000;
						PHDEBUG << currentText;
						PhStripText *text = new PhStripText(currentText, duration, PhStripDetect::MouthClosed);
						line->append(text);
					}

					// handle the out detect type
					// TODO
//					PhStripDetect::PhDetectType type = PhStripDetect::On;
//					if(elem.attribute("voice") == "off")
//						type = PhStripDetect::Off;
//					currentDetect->setType(type);

//					line->setLastDetect(currentDetect);

					_lineModel->append(line);
				}
			}
		}
	}

	xmlFile.close();
	delete domDoc;

	sort();

	setModified(true);

	return true;
}

bool PhStripDoc::exportDetXFile(QString fileName, PhTime lastTime)
{
	PHDEBUG << fileName;

	PhTimeCodeType tcType = _videoTimeCodeType;

	using boost::property_tree::ptree;
	ptree ptDetX;

	ptDetX.put("detx.header.title", _title.toStdString());
	ptDetX.put("detx.header.videofile", _videoPath.toStdString());
	ptDetX.put("detx.header.videofile.<xmlattr>.timestamp", PhTimeCode::stringFromTime(_videoTimeIn, tcType).toStdString());
	ptDetX.put("detx.header.videofile.<xmlattr>.tctype", PhTimeCode::getAverageFps(tcType));
	if(_videoForceRatio169)
		ptDetX.put("detx.header.videofile.<xmlattr>.forceRatio169", _videoForceRatio169);
	ptDetX.put("detx.header.last_position.<xmlattr>.timecode", PhTimeCode::stringFromTime(lastTime, tcType).toStdString());

	// export <role> list
	ptree roles;
	QMap<const PhPeople*, QString> idMap;

	QListIterator<PhPeople*> p = _peopleModel->iterator();
	while (p.hasNext()) {
		PhPeople *people = p.next();

		// Compute an unic id:
		QString id = computeDetXId(people->name());

		while(true) {
			if(!idMap.values().contains(id)) {
				idMap[people] = id;
				break;
			}
			else { // try to create unic id
				id += "_";
			}
		}

		ptree role;
		role.put("<xmlattr>.name", people->name().toStdString());
		role.put("<xmlattr>.id", id.toStdString());
		role.put("<xmlattr>.color", people->color().toStdString());
		role.put("image", people->picture().toStdString());

		roles.push_back(std::make_pair("role", role));
	}
	ptDetX.add_child("detx.roles", roles);

	// export <body>
	ptree ptBody;

	QList<PhStripObject*> objectList;

	QListIterator<PhStripLoop*> i = _loopModel->iterator();
	while (i.hasNext()) {
		PhStripLoop *loop = i.next();
		objectList.append(loop);
	}
	QListIterator<PhStripCut*> j = _cutModel->iterator();
	while(j.hasNext()) {
		PhStripCut *cut = j.next();
		objectList.append(cut);
	}
	QListIterator<PhStripLine*> k = _lineModel->iterator();
	while(k.hasNext()) {
		PhStripLine *line = k.next();
		objectList.append(line);
	}

	qSort(objectList.begin(), objectList.end(), PhStripObject::dtcomp);

	foreach (PhStripObject *obj, objectList) {
		if(PhStripLoop *loop = dynamic_cast<PhStripLoop*>(obj)) {
			ptree ptLoop;
			ptLoop.put("<xmlattr>.timecode", PhTimeCode::stringFromTime(loop->timeIn(), tcType).toStdString());
			ptBody.push_back(std::make_pair("loop", ptLoop));
		}
		else if(PhStripCut *cut = dynamic_cast<PhStripCut*>(obj)) {
			ptree ptShot;
			ptShot.put("<xmlattr>.timecode", PhTimeCode::stringFromTime(cut->timeIn(), tcType).toStdString());
			ptBody.push_back(std::make_pair("shot", ptShot));
		}
		else if(PhStripLine *sentence = dynamic_cast<PhStripLine*>(obj)) {
			PhTime timeOut = sentence->timeIn();

			ptree ptLine;
			ptLine.put("<xmlattr>.role", idMap[sentence->people()].toStdString());
			ptLine.put("<xmlattr>.track", boost::format("%d") % (int)(sentence->y() * 4));

			// Look if the sentence if off
			QListIterator<PhStripDetect *> detectIterator = sentence->detectModel()->iterator();
			while (detectIterator.hasNext()) {
				PhStripDetect *detect = detectIterator.next();
				if (detect->type() == PhStripDetect::Off) {
					ptLine.put("<xmlattr>.voice", "off");
					break;
				}
			}

			ptree lipsyncIn;
			lipsyncIn.put("<xmlattr>.timecode", PhTimeCode::stringFromTime(sentence->timeIn(), tcType).toStdString());
			lipsyncIn.put("<xmlattr>.type", openingDetectToString(sentence->typeIn()).toStdString());
			ptLine.push_back(std::make_pair("lipsync", lipsyncIn));

			QListIterator<PhStripDetect *> unlinkedDetectIterator = sentence->detectModel()->iterator();
			while (unlinkedDetectIterator.hasNext()) {
				PhStripDetect *unlinkedDetect = unlinkedDetectIterator.next();
				ptree lipsyncOut;
				lipsyncOut.put("<xmlattr>.link", "off");
				lipsyncOut.put("<xmlattr>.timecode", PhTimeCode::stringFromTime(sentence->timeIn() + unlinkedDetect->relativeTime(), tcType).toStdString());
				lipsyncOut.put("<xmlattr>.type", innerDetectToString(unlinkedDetect->type()).toStdString());
				ptLine.push_back(std::make_pair("lipsync", lipsyncOut));
			}

			QListIterator<PhStripText *> textIterator = sentence->textModel()->iterator();
			while (textIterator.hasNext()) {
				PhStripText *text = textIterator.next();
				timeOut += text->duration();

				ptree pText;
				pText.put("", text->content().toStdString());
				ptLine.push_back(std::make_pair("text", pText));

				ptree lipsyncOut;
				lipsyncOut.put("<xmlattr>.timecode", PhTimeCode::stringFromTime(timeOut, tcType).toStdString());

				if (!textIterator.hasNext()) {
					lipsyncOut.put("<xmlattr>.type", closingDetectToString(text->typeOut()).toStdString());
				}
				else {
					lipsyncOut.put("<xmlattr>.type", innerDetectToString(text->typeOut()).toStdString());
				}

				ptLine.push_back(std::make_pair("lipsync", lipsyncOut));
			}

			ptBody.push_back(std::make_pair("line", ptLine));
		}
	}

	ptDetX.add_child("detx.body", ptBody);

	std::ofstream file(fileName.toStdString());

#if BOOST_VERSION >= 105600
	boost::property_tree::write_xml(file, ptDetX, boost::property_tree::xml_writer_make_settings<std::string>('\t', 1));
#else
	boost::property_tree::write_xml(file, ptDetX, boost::property_tree::xml_writer_make_settings('\t', 1));
#endif

	file.close();

	return true;
}

QString PhStripDoc::computeDetXId(QString name)
{
	QString id = "";
	foreach (QChar c, name.toLower()) {
		if(c >= 'a' && c <= 'z')
			id.append(c);
		else
			id += '_';
	}

	return id;
}

bool PhStripDoc::checkMosTag2(QFile &f, int level, QString expected)
{
	QString name = PhFileTool::readString(f, level, expected);
	if(name != expected) {
		PHDEBUG << "!!!!!!!!!!!!!!!" << "Error reading " << expected << "!!!!!!!!!!!!!!!";
		f.close();
		return false;
	}
	return true;
}

bool PhStripDoc::checkMosTag(QFile &f, int level, MosTag expectedTag)
{
	MosTag tag = readMosTag(f, level, "checkMosTag");

	if(tag != expectedTag) {
		PHDEBUG << "!!!!!!!!!!!!!!!" << "Error reading " << tag << "instead of" << expectedTag << "!!!!!!!!!!!!!!!";
		f.close();
		return false;
	}
	return true;
}

PhTime PhStripDoc::readMosTime(QFile &f, PhTimeCodeType tcType, int level)
{
	return PhFileTool::readInt(f, level, "time") * PhTimeCode::timePerFrame(tcType) / 12;
}

PhStripText* PhStripDoc::readMosText(QFile &f, PhTimeCodeType tcType, int textLevel, int internLevel)
{
	QString content = PhFileTool::readString(f, 2, "content");

	PhTime timeIn = _videoTimeIn + readMosTime(f, tcType, internLevel);
	PhTime timeOut = _videoTimeIn + readMosTime(f, tcType, internLevel);

	// TODO
	PhStripText* text;// = new PhStripText(timeIn, NULL, timeOut, 0, content, 0.2f);

	PhFileTool::readInt(f, internLevel, "text");
	PhFileTool::readInt(f, internLevel, "text");
	PhFileTool::readInt(f, internLevel, "text");
	PhFileTool::readInt(f, internLevel, "text");
	PhFileTool::readInt(f, internLevel, "text");
	PhFileTool::readInt(f, internLevel, "text");

	PHDBG(textLevel) << PHNQ(PhTimeCode::stringFromTime(timeIn, tcType))
	                 << "->"
	                 << PHNQ(PhTimeCode::stringFromTime(timeOut, tcType))
	                 << PHNQ(content);
	return text;
}

PhStripDetect *PhStripDoc::readMosDetect(QFile &f, PhTimeCodeType tcType, int detectLevel, int internLevel)
{
	PhTime timeIn = _videoTimeIn + readMosTime(f, tcType, internLevel);
	PhTime timeOut = _videoTimeIn + readMosTime(f, tcType, internLevel);
	PhFileTool::readInt(f, internLevel, "detect type 1");
	int detectType2 = PhFileTool::readInt(f, internLevel, "detect type 2");
	int detectType3 = PhFileTool::readInt(f, internLevel, "detect type 3");
	PhStripDetect::PhDetectType type = PhStripDetect::Unknown;
	switch(detectType3) {
	case 9:
		type = PhStripDetect::SemiOff;
		break;
	case 10:
		type = PhStripDetect::Off;
		break;
	default:
		switch (detectType2) {
		case 0:
			type = PhStripDetect::On;
			break;
		case 2:
			type = PhStripDetect::MouthOpen;
			break;
		case 3:
			type = PhStripDetect::MouthClosed;
			break;
		case 4:
			type = PhStripDetect::Aperture;
			break;
		case 5:
			type = PhStripDetect::Advance;
			break;
		case 6:
			type = PhStripDetect::Labial;
			break;
		case 7:
			type = PhStripDetect::SemiLabial;
			break;
		case 8:
			type = PhStripDetect::Bowl;
			break;
		case 13:
		case 14:
			type = PhStripDetect::Dental;
			break;
		case 15:
			type = PhStripDetect::ArrowUp;
			break;
		case 16:
			type = PhStripDetect::ArrowDown;
			break;
		case 17:
			type = PhStripDetect::AmbianceStart;
			break;
		case 18:
			type = PhStripDetect::AmbianceEnd;
			break;
		}
	}

	for(int j = 0; j < 6; j++)
		PhFileTool::readShort(f, internLevel);
	PHDBG(detectLevel) << "detect: "
	                   << PhTimeCode::stringFromTime(timeIn, tcType)
	                   << PhTimeCode::stringFromTime(timeOut, tcType)
	                   << "type2:"
	                   << detectType2
	                   << "type3:"
	                   << detectType3
	                   << "type:"
	                   << type;
	// TODO
	return new PhStripDetect(type, timeIn);
	//return new PhStripDetect(type, timeIn, NULL, timeOut, 0, 0.2f);
}

bool PhStripDoc::readMosProperties(QFile &f, int level)
{
	QString originalTitle = PhFileTool::readString(f, level, "Titre de la versio originale");

	QString translatedTitle = PhFileTool::readString(f, level, "Titre de la version adaptée");

	_metaInformation["Titre de la version originale"] = originalTitle;
	_metaInformation["Titre de la version adaptée"] = translatedTitle;

	if(originalTitle.length())
		_title = originalTitle;
	else if(translatedTitle.length())
		_title = translatedTitle;

	_season = PhFileTool::readString(f, level, "Saison");
	_episode = PhFileTool::readString(f, level, "Episode/bobine");
	PhFileTool::readString(f, level, "Titre vo episode");
	PhFileTool::readString(f, level, "Titre adapté de l'épisode");
	PhFileTool::readString(f, level, "Durée");
	PhFileTool::readString(f, level, "Date");
	PhFileTool::readString(f, level, "Client");
	PhFileTool::readString(f, level, "Commentaires");
	PhFileTool::readString(f, level, "Détecteur");
	_authorName = PhFileTool::readString(f, level, "Auteur");
	PhFileTool::readString(f, level, "Studio");
	PhFileTool::readString(f, level, "D.A.");
	PhFileTool::readString(f, level, "Ingénieur du son");

	return true;
}

PhStripDoc::MosTag PhStripDoc::readMosTag(QFile &f, int level, QString name)
{
	unsigned short tag = PhFileTool::readShort(f, level, name);
	if(tag != 0xffff)
		return _mosTagMap[tag];

	PhFileTool::readShort(f, level, name);
	QString stringTag = PhFileTool::readString(f, level, name);

	if(stringTag == "CDocDoublage")
		return _mosTagMap[_mosNextTag++] = MosDub;
	else if(stringTag == "CDocPiste")
		return _mosTagMap[_mosNextTag++] = MosTrack;
	else if(stringTag == "CDocBlocTexte")
		return _mosTagMap[_mosNextTag++] = MosText;
	else if(stringTag == "CDocBlocDetection")
		return _mosTagMap[_mosNextTag++] = MosDetect;
	else if(stringTag == "CDocLangue")
		return _mosTagMap[_mosNextTag++] = MosLang;
	else if(stringTag == "CDocEtiquetteNom")
		return _mosTagMap[_mosNextTag++] = MosLabel;
	else if(stringTag == "CDocBoucle")
		return _mosTagMap[_mosNextTag++] = MosLoop;
	else if(stringTag == "CDocPlan")
		return _mosTagMap[_mosNextTag++] = MosCut;
	else if(stringTag == "CMosaicDoc")
		return _mosTagMap[_mosNextTag++] = MosDoc;
	else if(stringTag == "CDocProjet")
		return _mosTagMap[_mosNextTag++] = MosProject;
	else if(stringTag == "CDocProprietes")
		return _mosTagMap[_mosNextTag++] = MosProperties;
	else if(stringTag == "CDocOptionsProjet")
		return _mosTagMap[_mosNextTag++] = MosOptions;
	else if(stringTag == "CDocFilm")
		return _mosTagMap[_mosNextTag++] = MosMovie;
	else if(stringTag == "CDocPersonnage")
		return _mosTagMap[_mosNextTag++] = MosPeople;
	else if(stringTag == "CDocChutier")
		return _mosTagMap[_mosNextTag++] = MosBin;
	else {
		PHDEBUG << "!!!!!!!!!!!!!!! Unknown tag:" << stringTag << "!!!!!!!!!!!!!!!";
		f.close();
		return MosUnknown;
	}
}

bool PhStripDoc::readMosTrack(QFile &f, PhTimeCodeType tcType, QMap<int, PhPeople *> peopleMap, QMap<int, int> peopleTrackMap, int blocLevel, int textLevel, int detectLevel, int labelLevel, int level, int internLevel)
{
	QList<PhStripDetect*> detectList;
	QList<PhStripText*> textList1, textList2;
	int detectCount = PhFileTool::readInt(f, detectLevel, "track CDocBlocDetection count");

	if(detectCount) {
		if(!checkMosTag(f, blocLevel, MosDetect))
			return false;

		for(int i = 0; i < detectCount; i++) {
			if(i > 0)
				PhFileTool::readShort(f, level, "detect tag");
			detectList.append(readMosDetect(f, tcType, detectLevel, internLevel));
		}
	}

	int langCount = PhFileTool::readInt(f, blocLevel, "track CDocLangue count");
	if(langCount) {
		if(!checkMosTag(f, blocLevel, MosLang))
			return false;
	}

	int textCount = PhFileTool::readInt(f, blocLevel, "track CDocBlocTexte count");
	if(textCount) {
		if(!checkMosTag(f, blocLevel, MosText))
			return false;

		for(int i = 0; i < textCount; i++) {
			if(i > 0)
				PhFileTool::readShort(f, level, "text tag");
			textList1.append(readMosText(f, tcType, textLevel, internLevel));
		}
	}

	int peopleId = PhFileTool::readInt(f, level, "people id");

	for(int k = 0; k < 2; k++) {
		int count = PhFileTool::readInt(f, level, "track other count");
		if(count == 0)
			continue;
		MosTag tag = readMosTag(f, level, "track other tag");
		switch(tag) {
		case MosText:
			for(int i = 0; i < count; i++) {
				if(i > 0)
					PhFileTool::readShort(f, level, "text tag");
				textList2.append(readMosText(f, tcType, textLevel, internLevel));
			}
			break;
		case MosLabel:
			for(int i = 0; i < count; i++) {
				if(i > 0)
					PhFileTool::readShort(f, level, "label tag");
				PhTime labelTime = _videoTimeIn + readMosTime(f, tcType, internLevel);
				for(int j = 0; j < 6; j++)
					PhFileTool::readShort(f, internLevel);
				PHDBG(labelLevel) << "label" << PhTimeCode::stringFromTime(labelTime, tcType);
			}
			break;
		default:
			PHDEBUG << "!!!!!!!!!!!!!!! Unknown tag:" << PHNQ(QString::number(tag, 16)) << "!!!!!!!!!!!!!!!";
			f.close();
			return false;
		}
	}

	PhPeople *people = peopleMap[peopleId];
	int track = peopleTrackMap[peopleId];

	PHDBG(textLevel) << "Adding" << textList1.count() << "texts in list 1";
	foreach(PhStripText* text, textList1) {
		//FIXME
		//text->setPeople(people);
		//text->setY(track / 5.0);
		//this->addText(text);
	}

	PHDBG(textLevel) << "Adding" << textList2.count() << "texts in  list 2";
	foreach(PhStripText* text, textList2) {
		//FIXME
		//text->setPeople(people);
		//text->setY(track);
		//this->addText(text, true);
	}

	foreach(PhStripDetect* detect, detectList) {
		//FIXME
		//detect->setPeople((people));
		//detect->setY(track);
		//this->addDetect(detect);
	}

	return true;
}
bool PhStripDoc::modified() const
{
	return _modified;
}

void PhStripDoc::setModified(bool modified)
{
	if (modified) {
		emit changed();
	}
	_modified = modified;
}

PhStripCutModel *PhStripDoc::cutModel() const
{
	return _cutModel;
}

PhStripLoopModel *PhStripDoc::loopModel() const
{
	return _loopModel;
}

void PhStripDoc::assignLineToPeople(int lineIndex, QString peopleName)
{
	// find people with that name
	QListIterator<PhPeople*> i = _peopleModel->iterator();
	while (i.hasNext()) {
		PhPeople *people = i.next();
		if (people->name() == peopleName) {
			_lineModel->assignLineToPeople(lineIndex, people);
			return;
		}
	}

	PHDEBUG << lineIndex << " " << peopleName << " not found";
}

void PhStripDoc::addLine(PhTime time, float y, PhStripDetect::PhDetectType typeIn)
{
	// find the closest line in the past in this track
	PhTime peopleTime = PHTIMEMIN;
	PhPeople *people = NULL;
	QListIterator<PhStripLine *> i = _lineModel->iterator();
	while (i.hasNext()) {
		PhStripLine *line = i.next();
		if (line->y() == y && line->timeOut() < time && line->timeOut() > peopleTime) {
			peopleTime = line->timeOut();
			people = line->people();
		}
	}

	if (people == NULL) {
		// find the closest line in the future in this track
		peopleTime = PHTIMEMAX;
		QListIterator<PhStripLine *> i = _lineModel->iterator();
		while (i.hasNext()) {
			PhStripLine *line = i.next();
			if (line->y() == y && line->timeIn() > time && line->timeIn() < peopleTime) {
				peopleTime = line->timeIn();
				people = line->people();
			}
		}
	}

	if (people == NULL) {
		people = _peopleModel->create("New");
	}

	_lineModel->add(time, y, people, typeIn);
}

void PhStripDoc::updateTimeIn()
{
	PhTime timeIn = _lineModel->timeIn();
	PHDEBUG << timeIn;
	setTimeIn(timeIn);
}

void PhStripDoc::updateTimeOut()
{
	PhTime timeOut = _lineModel->timeOut();
	setTimeOut(timeOut);
}

void PhStripDoc::setTimeIn(PhTime timeIn)
{
	if (_timeIn != timeIn) {
		PHDEBUG << timeIn;
		_timeIn = timeIn;
		emit timeInChanged();
	}
}

void PhStripDoc::setTimeOut(PhTime timeOut)
{
	if (_timeOut != timeOut) {
		PHDEBUG << timeOut;
		_timeOut = timeOut;
		emit timeOutChanged();
	}
}

int PhStripDoc::deletePeople(int peopleIndex)
{
	QString peopleName = _peopleModel->index(peopleIndex).data(PhStripPeopleModel::NameRole).toString();

	int usages = 0;
	QListIterator<PhStripLine*> i = _lineModel->iterator();
	while (i.hasNext()) {
		PhStripLine *line = i.next();
		if (line->people()->name() == peopleName) {
			usages += 1;
		}
	}

	if (usages == 0) {
		_peopleModel->remove(peopleIndex);
	}

	return usages;
}

PhStripPeopleModel *PhStripDoc::peopleModel() const
{
	return _peopleModel;
}

void PhStripDoc::sort()
{
	//FIXME
	//qSort(_texts1.begin(), _texts1.end(), PhStripObject::dtcomp);
	//qSort(_texts2.begin(), _texts2.end(), PhStripObject::dtcomp);
	//qSort(_detects.begin(), _detects.end(), PhStripObject::dtcomp);
	//qSort(_cuts.begin(), _cuts.end(), PhStripObject::dtcomp);
	//qSort(_loops.begin(), _loops.end(), PhStripObject::dtcomp);
}

bool PhStripDoc::importMosFile(const QString &fileName)
{
	PHDEBUG << "===============" << fileName << "===============";

	QFile f(fileName);
	if(!f.exists()) {
		PHDEBUG << "File doesn't exists : " << fileName;
		return false;
	}

	if(!f.open(QFile::ReadOnly)) {
		PHDEBUG << "Unable to open : " << fileName;
		return false;
	}

	this->reset();

	_filePath = fileName;
	_title = QFileInfo(fileName).baseName();

	int level = 1;
	int ok = 0;
	int propLevel = ok;
	int peopleLevel = level;
	int textLevel = level;
	int detectLevel = level;
	int blocLevel = level;
	int cutLevel = level;
	int loopLevel = level;
	int labelLevel = level;
	int internLevel = 2;

	if(!checkMosTag2(f, blocLevel, "NOBLURMOSAIC"))
		return false;

	_generator = "Mosaic";

	PhFileTool::readShort(f, blocLevel, "CMosaicDoc");
	PhFileTool::readShort(f, blocLevel, "CMosaicDoc");

	if(!checkMosTag2(f, blocLevel, "CMosaicDoc"))
		return false;

	PhFileTool::readShort(f, blocLevel, "CDocProjet");
	PhFileTool::readShort(f, blocLevel, "CDocProjet");

	if(!checkMosTag2(f, blocLevel, "CDocProjet"))
		return false;

	PhFileTool::readShort(f, blocLevel, "CDocProprietes");
	PhFileTool::readShort(f, blocLevel, "CDocProprietes");

	if(!checkMosTag2(f, blocLevel, "CDocProprietes"))
		return false;

	readMosProperties(f, propLevel);

	PhFileTool::readShort(f, blocLevel, "CDocOptionsProjet");

	// read a number that makes a difference wether it's 3 or 4 later
	unsigned short mosVersion = PhFileTool::readShort(f, blocLevel, "CDocOptionsProjet mosVersion");


	if(!checkMosTag2(f, blocLevel, "CDocOptionsProjet"))
		return false;

	PhTimeCodeType tcType;
	unsigned short type = PhFileTool::readInt(f, level, "type");
	bool drop = PhFileTool::readInt(f, level, "drop") != 0;
	switch(type) {
	case 0:
		if(drop)
			tcType = PhTimeCodeType2398;
		else
			tcType = PhTimeCodeType24;
		break;
	default:
		tcType = PhTimeCodeType25;
		break;
	}
	PHDBG(ok) << "TC Type:" << tcType;


	if(mosVersion == 4) {
		//		qDebug() << "reading extrasection ???";
		//		PhFileTool::readInt(f, logLevel, "loop continuous numbering");
		PhFileTool::readShort(f, level);
		PhFileTool::readShort(f, level);
	}

	for(int j = 0; j < 8; j++)
		PhFileTool::readShort(f, level);

	PhFileTool::readInt(f, blocLevel, "CDocFilm count");
	PhFileTool::readShort(f, blocLevel, "CDocFilm");
	PhFileTool::readShort(f, blocLevel, "CDocFilm");

	if(!checkMosTag2(f, blocLevel, "CDocFilm"))
		return false;

	unsigned short peopleCount = PhFileTool::readInt(f, blocLevel, "CDocPersonnage count");

	PhFileTool::readShort(f, blocLevel, "CDocPersonnage");
	int peopleType = PhFileTool::readShort(f, blocLevel, "CDocPersonnage");

	if(!checkMosTag2(f, blocLevel, "CDocPersonnage"))
		return false;

	QMap<int, PhPeople*> peopleMap;
	QMap<int, int> peopleTrackMap;
	for(int i = 0; i < peopleCount; i++) {
		if(i > 0)
			PhFileTool::readShort(f, level, "people tag");

		int peopleId = PhFileTool::readInt(f, peopleLevel, "peopleId");

		QString name = PhFileTool::readString(f, peopleLevel, "people name");
		PhPeople *people = new PhPeople(name, "#000000");
		peopleMap[peopleId] = people;
		this->addPeople(people);

		peopleTrackMap[peopleId] = PhFileTool::readInt(f, peopleLevel, "people track") - 1;
		for(int j = 0; j < 6; j++)
			PhFileTool::readShort(f, level);


		if(peopleType == 2)
			PhFileTool::readString(f, peopleLevel, "date 1");
	}

	int peopleCount2 = PhFileTool::readInt(f, blocLevel, "people count 2");
	if(peopleCount2 != peopleCount) {
		PHDEBUG << "people count not corresponding:" << peopleCount << "/" << peopleCount2;
		//		return false;
	}
	PhFileTool::readShort(f, blocLevel, "CDocVideo");
	unsigned short videoType = PhFileTool::readShort(f, blocLevel, "CDocVideo");

	if(!checkMosTag2(f, blocLevel, "CDocVideo"))
		return false;

	QString videoFilePath = PhFileTool::readString(f, ok, "Video path");
	this->setVideoFilePath(videoFilePath);
	PhTime videoTimeIn = readMosTime(f, tcType, internLevel);
	this->setVideoTimeIn(videoTimeIn, tcType);
	PHDBG(ok) << "Timestamp:" << PhTimeCode::stringFromTime(_videoTimeIn, tcType);

	if(videoType == 3) {
		PhFileTool::readShort(f, level, "videoType3");
		PhFileTool::readShort(f, level, "videoType3");
	}

	PhFileTool::readShort(f, level);
	PhFileTool::readShort(f, level);

	unsigned short cutCount = PhFileTool::readInt(f, blocLevel, "cut count");
	if(cutCount) {
		if(!checkMosTag(f, blocLevel, MosCut))
			return false;

		for(int j = 0; j < cutCount; j++) {
			if((j > 0) && !checkMosTag(f, level, MosCut))
				return false;
			PhTime cutTime = _videoTimeIn + readMosTime(f, tcType, internLevel);
			PHDBG(cutLevel) << "cut:" << PhTimeCode::stringFromTime(cutTime, tcType);
			this->addCut(new PhStripCut(cutTime, PhStripCut::Simple));
		}
	}

	QString script = PhFileTool::readString(f, ok, "script");

	PhFileTool::readInt(f, blocLevel, "dub count");
	if(!checkMosTag(f, blocLevel, MosDub))
		return false;

	for(int j = 0; j < 8; j++)
		PhFileTool::readShort(f, level, "CDocDoublage");

	int trackCount = PhFileTool::readInt(f, blocLevel, "track count");
	if(!checkMosTag(f, blocLevel, MosTrack))
		return false;

	for(int track = 0; track < trackCount; track++) {
		PHDBG(level) << "====== READING TRACK " << track << "======";
		if((track > 0) && !checkMosTag(f, level, MosTrack))
			return false;
		if(!readMosTrack(f, tcType, peopleMap, peopleTrackMap, blocLevel, textLevel, detectLevel, labelLevel, level, internLevel))
			return false;
	}

	PHDBG(level) << "====== END OF TRACK ======";

	for(int k = 0; k < 2; k++) {
		int loopCount = PhFileTool::readInt(f, loopLevel, "loop count");
		if(loopCount == 0)
			continue;
		if(!checkMosTag(f, blocLevel, MosLoop))
			return false;
		for(int i = 0; i < loopCount; i++) {
			if((i > 0) && !checkMosTag(f, level, MosLoop))
				return false;
			int number = PhFileTool::readInt(f, loopLevel, "loop number");

			PhTime loopTime = _videoTimeIn + readMosTime(f, tcType, internLevel);
			QString label = PhFileTool::readString(f, loopLevel, "loop name");
			if(k == 1)
				label = "off";
			else if(label.isEmpty())
				label = QString::number(number);
			this->addLoop(new PhStripLoop(loopTime, label));
		}
	}

	for(int j = 0; j < 4; j++)
		PhFileTool::readShort(f, level, "after loop1");

	//	if(strangeNumber2 == 1) {
	//		for(int j = 0; j < 9; j++)
	//			PhFileTool::readShort(f, level, "after loop2");
	//	}

	//	if(!checkMosTag(f, blocLevel, MosBin))
	//		return false;

	//	for(int j = 0; j < 2; j++)
	//		PhFileTool::readShort(f, level);

	PHDEBUG << "_______________" << "reading ok" << "_______________";

	f.close();

	// FIXME
	//if((this->texts().count() == 0) && (this->texts(true).count())) {
	//	PHDEBUG << "Switching primary and secondary text lists";
	//	foreach(PhStripText* text, _alternateTexts) {
	//		_texts->append(text);
	//	}
	//	_alternateTexts.clear();
	//}

	sort();

	setModified(true);

	return true;
}

PhTime PhStripDoc::ComputeDrbTime1(PhTime offset, PhTime value, PhTimeCodeType tcType)
{
	return (offset + value) * PhTimeCode::timePerFrame(tcType) / 400000;
}

PhTime PhStripDoc::ComputeDrbTime2(PhTime offset, PhTime value, PhTimeCodeType tcType)
{
	return (offset + value * 50000) * PhTimeCode::timePerFrame(tcType) / 400000;
}

bool PhStripDoc::importDrbFile(const QString &fileName)
{
	PHDEBUG << fileName;
	QFile file(fileName);

	reset();

	PhTimeCodeType tcType = PhTimeCodeType25;

	PhTime offset = 0;

	if(file.open(QIODevice::ReadOnly)) {
		QTextStream ts(&file);
		// Detect text codec
		if(file.peek(2).at(1) == 0)
			ts.setCodec("UTF-16");

		while(!ts.atEnd()) {
			QString line = ts.readLine();
			if(line.startsWith("CV:")) {
				_videoPath = line.remove("CV:");
				PHDEBUG << "videoPath:" << _videoPath;
			}
			else if(line.startsWith("O:")) {
				offset = line.remove("O:").toLongLong();
				_videoTimeIn = ComputeDrbTime1(offset, 0, tcType);
				PHDEBUG << "videoTimeIn:" << _videoTimeIn << line;
			}
		}
	}
	else {
		PHDEBUG << "Unable to open:" << fileName;
		return false;
	}

	QString dirName = fileName;
	dirName.remove(".drb", Qt::CaseInsensitive);

	QFile loopFile(dirName + "/boucle.xml");
	if(!loopFile.open(QIODevice::ReadOnly)) {
		PHDEBUG << "Unable to open boucle.xml";
		return false;
	}

	QDomDocument loopDoc;
	if(!loopDoc.setContent(&loopFile)) {
		loopFile.close();
		PHDEBUG << "Unable to parse boucle.xml";
		return false;
	}

	int loopNumber = 1;
	QDomNodeList loopList = loopDoc.elementsByTagName("Row");
	for (int i = 0; i < loopList.length(); i++) {
		QDomElement loopElement = loopList.at(i).toElement();
		QString type = loopElement.elementsByTagName("Type").at(0).toElement().text();
		PhTime timeIn = ComputeDrbTime1(offset, loopElement.elementsByTagName("Debut").at(0).toElement().text().toLongLong(), tcType);
		if(type == "BOUCLE") {
			this->addLoop(new PhStripLoop(timeIn, QString::number(loopNumber++)));
		}
		else if (type == "PLAN") {
			this->addCut(new PhStripCut(timeIn, PhStripCut::PhCutType::Simple));
		}
	}

	loopFile.close();

	// Opening the XML file
	QFile peopleFile(dirName + "/intervenant.xml");
	if(!peopleFile.open(QIODevice::ReadOnly)) {
		PHDEBUG << "Unable to open intervenant.xml";
		return false;
	}

	// Loading the DOM (document object model)
	QDomDocument peopleDoc;
	if (!peopleDoc.setContent(&peopleFile)) {
		peopleFile.close();
		PHDEBUG << "The XML document seems to be bad formed intervenant.xml";
		return false;
	}

	bool result = true;
	QMap<int, PhPeople*> peopleMap;

	QDomNodeList peopleList = peopleDoc.elementsByTagName("Row");
	for (int i = 0; i < peopleList.length(); i++) {
		QDomElement peopleElement = peopleList.at(i).toElement();
		int id = peopleElement.elementsByTagName("Id").at(0).toElement().text().toInt();
		QString name = peopleElement.elementsByTagName("Nom").at(0).toElement().text();
		PhPeople *people = new PhPeople(name);
		peopleMap[id] = people;
	}

	peopleFile.close();

	foreach(PhPeople *people, peopleMap.values())
		this->addPeople(people);

	QDir dir(dirName);

	foreach(QString name, dir.entryList(QStringList("*.dat"))) {
		QString subFileName = dir.filePath(name);
		QFile f(subFileName);
		if(f.open(QIODevice::ReadOnly)) {
			QTextStream ts(&f);

			// Detect text codec
			if(f.peek(2).at(1) == 0)
				ts.setCodec("UTF-16");

			QString xmlString = "";

			while(!ts.atEnd()) {
				QString line = ts.readLine();
				if(!line.startsWith("<COPYRIGHT"))
					xmlString += line + "\n";
				if(line == "</SYNCHRONOS>")
					break;
			}
			f.close();

			QDomDocument subDoc;

			QString errorMsg;
			int errorLine, errorColumn;
			if(subDoc.setContent(xmlString, &errorMsg, &errorLine, &errorColumn)) {
				QDomNodeList textList = subDoc.elementsByTagName("TEXT");
				for(int i = 0; i < textList.count(); i++) {
					QDomElement textElement = textList.at(i).toElement();
					int peopleId = textElement.elementsByTagName("ID_INTER").at(0).toElement().text().toInt();
					PhPeople *people = peopleMap[peopleId];
					PhTime timeIn = ComputeDrbTime2(offset, textElement.elementsByTagName("X1").at(0).toElement().text().toLongLong() - 150, tcType);
					PhTime timeOut = ComputeDrbTime2(offset, textElement.elementsByTagName("X2").at(0).toElement().text().toLongLong() - 150, tcType);
					int y1 = textElement.elementsByTagName("Y1").at(0).toElement().text().toInt();
					int y2 = textElement.elementsByTagName("Y2").at(0).toElement().text().toInt();
					float y = y1 / 150.0f;
					float height = (y2 - y1) / 150.0f;

					QString content = textElement.elementsByTagName("VALUE").at(0).toElement().text();

					PHDEBUG << PhTimeCode::stringFromTime(timeIn, tcType) << PhTimeCode::stringFromTime(timeOut, tcType) << content;
					//FIXME
					//this->addText(new PhStripText(timeIn, people, timeOut, y, content, height));
				}
			}
			else {
				PHDEBUG << "Unable to parse" << subFileName << ":" << errorMsg << "@" << errorLine << "," << errorColumn;
				result = false;
			}
		}
		else {
			PHDEBUG << "Unable to open" << subFileName;
			result = false;
		}
	}

	sort();

	return result;
}

#ifdef USE_SYN6
bool PhStripDoc::importSyn6File(const QString &fileName)
{
	QSqlDatabase db;
	db =  QSqlDatabase::addDatabase("QSQLITE");
	db.setDatabaseName(fileName);
	if(!db.open()) {
		PHDEBUG << "Error opening the sqlite document:" << db.lastError().text();
		return false;
	}
	PHDEBUG << "database opened: " << db.tables().count() << "tables.";

	QSqlQuery query(db);

	PhTimeCodeType tcType = PhTimeCodeType25;

	// Reading video file and timestamp
	PhTime offset = 0;
	if(query.exec("SELECT * FROM PREFERENCE;")) {
		PHDEBUG << "PREFERENCE:";
		while(query.next()) {
			switch(query.value(0).toInt()) {
			case 6:
				offset = query.value(3).toLongLong();
				_videoTimeIn = ComputeDrbTime1(offset, 0, tcType);
				break;
			case 11:
				_videoPath = query.value(2).toString().replace("\\\\", "\\");
				break;
			}
		}
	}

	// Reading peoples
	QMap<int, PhPeople*> peopleMap;
	if(query.exec("SELECT * FROM PERSONNAGE;")) {
		PHDEBUG << "PERSONNAGE:";

		while(query.next()) {
			int id = query.value(0).toInt();
			QString name = query.value(1).toString();
			PhPeople *people = new PhPeople(name);
			peopleMap[id] = people;
		}
	}
	else
		PHDEBUG << "query failed";

	foreach(PhPeople *people, peopleMap.values())
		this->addPeople(people);

	// Reading loops
	if(query.exec("SELECT * FROM OBJET_TC;")) {
		PHDEBUG << "OBJET_TC:";
		while(query.next()) {
			for(int i = 0; i < 7; i++)
				PHDEBUG << i << query.value(i);
			PhTime time = ComputeDrbTime2(offset, query.value(2).toLongLong(), tcType);
			switch(query.value(1).toInt()) {
			case 2:
				this->addCut(new PhStripCut(time, PhStripCut::Simple));
				break;
			case 7:
				this->addLoop(new PhStripLoop(time, QString::number(query.value(4).toInt())));
				break;
			}
		}
	}

	// Reading texts
	if(query.exec("SELECT * FROM TEXTE;")) {
		PHDEBUG << "TEXTE:";
		while(query.next()) {
			int peopleId = query.value(0).toInt();
			PhPeople* people = (peopleMap.contains(peopleId)) ? peopleMap[peopleId] : NULL;
			PhTime timeIn = ComputeDrbTime2(offset, query.value(3).toLongLong() - 150, tcType);
			PhTime timeOut = ComputeDrbTime2(offset, query.value(4).toLongLong() - 150, tcType);
			int y1 = query.value(6).toInt();
			int y2 = query.value(5).toInt();
			float y = y1 / 150.0f;
			float height = (y2 - y1) / 150.0f;
			QString content = query.value(7).toString();
			//FIXME
			//this->addText(new PhStripText(timeIn, people, timeOut, y, content, height));
			PHDEBUG << timeIn << timeOut << content;
		}
	}

	db.close();

	sort();

	return true;
}
#endif

bool PhStripDoc::openStripFile(const QString &fileName)
{
	PHDEBUG << fileName;
	bool result = false;

	QString extension = QFileInfo(fileName).suffix().toLower();
	// Try to open the document
	if(extension == "detx") {
		result = importDetXFile(fileName);
	}
	else if(extension == "mos") {
		result = importMosFile(fileName);
	}
	else if(extension == "drb") {
		result = importDrbFile(fileName);
	}
#ifdef USE_SYN6
	else if(extension == "syn6") {
		result = importSyn6File(fileName);
	}
#endif
	else if(extension == "strip" or extension == "joker") {
		QFile xmlFile(fileName);
		if(!xmlFile.open(QIODevice::ReadOnly)) {
			PHDEBUG << "Unable to open" << fileName << xmlFile.errorString();
			return false;
		}

		// Loading the DOM
		QDomDocument *domDoc = new QDomDocument();
		if (!domDoc->setContent(&xmlFile)) {
			xmlFile.close();
			delete domDoc;
			PHDEBUG << "The XML document seems to be bad formed" << fileName;
			return false;
		}
		xmlFile.close();

		PHDEBUG << ("Start parsing " + fileName);
		QDomElement stripDocument = domDoc->documentElement();

		if(stripDocument.tagName() != "strip" && stripDocument.tagName() != "joker") {
			PHDEBUG << "Bad root element :" << stripDocument.tagName();
			return false;
		}

		result = true;

		// Reading the media nodes
		QDomNodeList mediaList = stripDocument.elementsByTagName("media");
		for(int i = 0; i < mediaList.count(); i++) {
			QDomElement media = mediaList.at(i).toElement();
			QString type = media.attribute("type");
			PHDEBUG << "line" << type;
			if(type == "detx")
				result = importDetXFile(media.text());
			else if(type == "mos")
				result = importMosFile(media.text());
			else if(type == "video") {
				_videoPath = media.text();

				float fps = media.attribute("frameRate").toFloat();
				_videoTimeCodeType = PhTimeCode::computeTimeCodeType(fps);
				_videoTimeIn = PhTimeCode::timeFromString(media.attribute("tcStamp"), _videoTimeCodeType);

				_videoForceRatio169 = media.attribute("forceRatio").toLower() == "yes";
				_videoDeinterlace = media.attribute("deinterlace").toLower() == "yes";
			}
		}

		if(stripDocument.elementsByTagName("state").count()) {
			QDomElement state = stripDocument.elementsByTagName("state").at(0).toElement();
			_lastTime = state.attribute("lastTime").toLongLong();
			if(_lastTime == 0)
				_lastTime = PhTimeCode::timeFromString(state.attribute("lastTimeCode"), _videoTimeCodeType);
		}

		if(stripDocument.elementsByTagName("peoples").count()) {
			QDomNodeList chars = stripDocument.elementsByTagName("peoples").at(0).childNodes();
			for(int i = 0; i < chars.count(); i++) {
				QString color = chars.at(i).toElement().attribute("color");
				QString name = chars.at(i).toElement().attribute("name");
				PhPeople *people = peopleByName(name);
				if(people)
					people->setColor(color);
			}
		}

		delete domDoc;

	}
	setModified(false);
	return result;
}

bool PhStripDoc::saveStripFile(const QString &fileName, PhTime lastTime)
{
	PHDEBUG << fileName;
	QFile file(fileName);

	// open a file
	if (!file.open(QIODevice::WriteOnly)) {
		PHDEBUG << "an error occur while saving the strip document";
		return false;
	}
	else {
		//if file is successfully opened then create XML
		QXmlStreamWriter* xmlWriter = new QXmlStreamWriter();
		// set device (here file)to streamwriter
		xmlWriter->setDevice(&file);
		// Writes a document start with the XML version number version.

		// Positive numbers indicate spaces, negative numbers tabs.
		xmlWriter->setAutoFormattingIndent(-1);
		xmlWriter->setAutoFormatting(true);

		// Indent is just for keeping in mind XML structure
		xmlWriter->writeStartDocument();
		xmlWriter->writeStartElement("joker");
		{
			xmlWriter->writeStartElement("meta");
			{
				xmlWriter->writeStartElement("generator");
				xmlWriter->writeAttribute("name", "Joker");
#ifdef APP_VERSION
				xmlWriter->writeAttribute("version", APP_VERSION);
#endif
				xmlWriter->writeEndElement();

				if(_filePath.length() > 0) {
					QFileInfo info(_filePath);
					xmlWriter->writeStartElement("media");
					xmlWriter->writeAttribute("type", info.suffix());
					xmlWriter->writeCharacters(filePath());
					xmlWriter->writeEndElement();
				}

				xmlWriter->writeStartElement("media");
				xmlWriter->writeAttribute("type", "video");
				xmlWriter->writeAttribute("tcStamp", PhTimeCode::stringFromTime(_videoTimeIn, _videoTimeCodeType));
				xmlWriter->writeAttribute("frameRate", QString::number(PhTimeCode::getAverageFps(_videoTimeCodeType)));

				if(_videoForceRatio169)
					xmlWriter->writeAttribute("forceRatio", "yes");
				if(_videoDeinterlace)
					xmlWriter->writeAttribute("deinterlace", "yes");
				xmlWriter->writeCharacters(_videoPath);
				xmlWriter->writeEndElement();

				xmlWriter->writeStartElement("state");
				xmlWriter->writeAttribute("lastTime", QString::number(lastTime));
				xmlWriter->writeEndElement();
			}
			xmlWriter->writeEndElement();

			xmlWriter->writeStartElement("peoples");
			{
				QListIterator<PhPeople*> i = _peopleModel->iterator();
				while (i.hasNext()) {
					const PhPeople *ppl = i.next();
					xmlWriter->writeStartElement("people");
					xmlWriter->writeAttribute("name", ppl->name());
					xmlWriter->writeAttribute("color", ppl->color());
					xmlWriter->writeEndElement();
				}
			}
			xmlWriter->writeEndElement();

		}
		xmlWriter->writeEndElement();

		xmlWriter->writeEndDocument();
		delete xmlWriter;
	}

	return true;
}

void PhStripDoc::generate(QString content, int loopCount, int peopleCount, PhTime spaceBetweenText, int textCount, int trackCount, PhTime videoTimeIn)
{
	this->reset();
	_title = "Generate file";
	_translatedTitle = "Fichier généré";
	_episode = "1";
	_season = "1";
	_videoTimeIn = videoTimeIn;
	_videoTimeCodeType = PhTimeCodeType25;
	_lastTime = _videoTimeIn;

	if (trackCount > 4 || trackCount < 1)
		trackCount = 3;

	QStringList names;
	names.append("Actor");
	names.append("Actress");
	names.append("Jack");
	names.append("Jane");

	int nbNames = names.length();
	// Creation of the Peoples
	for (int i = 1; i <= peopleCount; i++) {
		PhPeople *people = new PhPeople(names.at(i % nbNames) + " " + QString::number(i), "black");
		this->addPeople(people);
	}

	PhTime time = _videoTimeIn;
	// Creation of the text
	for (int i = 0; i < textCount; i++) {
		PhTime timeIn = time;
		PhTime timeOut = timeIn + content.length() * 1000;

		//FIXME

		//Make people "talk" alternaly
		//PhPeople *people = _peoples[i % peopleCount];
		//this->addText(new PhStripText(timeIn, people, timeOut, i % trackCount / 4.0, content, 0.25f));

		// So the texts are all one after the other
		time += spaceBetweenText;
	}

	// Add a loop per minute
	for(int i = 0; i < loopCount; i++)
		this->addLoop(new PhStripLoop(_videoTimeIn + i * PHTIMEBASE * 60, QString::number(i)));

	setModified(true);
}

void PhStripDoc::reset()
{
	_lastTime = 0;

	_peopleModel->clear();
	_lineModel->clear();
	_cutModel->clear();
	_loopModel->clear();

	/* Note: clearing a QList does not free its elements. */
	//FIXME
//	qDeleteAll(_sentences1);
//	_sentences1.clear();
//	qDeleteAll(_sentences2);
//	_sentences2.clear();

	_generator = "???";
	_title = "";
	_translatedTitle = "";
	_episode = "";
	_season = "";
	_videoPath = "";
	_videoTimeIn = 0;
	_videoTimeCodeType = PhTimeCodeType25;
	_videoDeinterlace = false;
	_authorName = "";
	_videoForceRatio169 = false;
	_generator = "";
	_mosNextTag = 0x8008;

	setModified(false);
}

void PhStripDoc::addCut(PhStripCut *cut)
{
	_cutModel->append(cut);
	setModified(true);
}

void PhStripDoc::addLoop(PhStripLoop *loop)
{
	_loopModel->append(loop);
	setModified(true);
}

void PhStripDoc::addPeople(PhPeople *people)
{
	_peopleModel->append(people);
	setModified(true);
}

PhPeople *PhStripDoc::peopleByName(QString name) const
{
	QListIterator<PhPeople*> i = _peopleModel->iterator();
	while (i.hasNext()) {
		PhPeople *people = i.next();
		if(people && people->name() == name)
			return people;
	}
	return NULL;
}

PhStripLine *PhStripDoc::nextLine(PhTime time) const
{
	PhStripLine * result = NULL;
	QListIterator<PhStripLine*> i = _lineModel->iterator();
	while (i.hasNext()) {
		PhStripLine *line = i.next();
		if(line->timeIn() > time) {
			if(!result || (line->timeIn() < result->timeIn()) )
				result = line;
		}
	}
	return result;
}

PhStripLine *PhStripDoc::nextLine(PhPeople *people, PhTime time) const
{
	PhStripLine * result = NULL;
	QListIterator<PhStripLine*> i = _lineModel->iterator();
	while (i.hasNext()) {
		PhStripLine *line = i.next();
		if((line->people() == people) && (line->timeIn() > time)) {
			if(!result || (line->timeIn() < result->timeIn()) )
				result = line;
		}
	}
	return result;
}

PhStripLine *PhStripDoc::nextLine(QList<PhPeople *> peopleList, PhTime time) const
{
	PhStripLine * result = NULL;
	QListIterator<PhStripLine*> i = _lineModel->iterator();
	while (i.hasNext()) {
		PhStripLine *line = i.next();
		if(peopleList.contains(line->people()) && (line->timeIn() > time)) {
			if(!result || (line->timeIn() < result->timeIn()) )
				result = line;
		}
	}
	return result;
}

PhTime PhStripDoc::previousTextTime(PhTime time) const
{
	PhTime previousTextTime = PHTIMEMIN;

	QListIterator<PhStripLine*> i = _lineModel->iterator();
	while (i.hasNext()) {
		PhStripLine *line = i.next();
		PhTime timeIn = line->timeIn();
		if((timeIn < time) && (timeIn > previousTextTime) ) {
			previousTextTime = timeIn;
		}

		QListIterator<PhStripText*> j = line->textModel()->iterator();
		while(j.hasNext()) {
			PhStripText *text = j.next();
			timeIn += text->duration();
			if((timeIn < time) && (timeIn > previousTextTime) ) {
				previousTextTime = timeIn;
			}
		}

		QListIterator<PhStripDetect *> k = line->detectModel()->iterator();
		while(k.hasNext()) {
			PhStripDetect *detect = k.next();
			PhTime detectTime = line->timeIn() + detect->relativeTime();
			if((detectTime < time) && (detectTime > previousTextTime) ) {
				previousTextTime = detectTime;
			}
		}
	}

	return previousTextTime;
}

PhTime PhStripDoc::previousLoopTime(PhTime time) const
{
	PhTime previousLoopTime = PHTIMEMIN;

	QListIterator<PhStripLoop*> i = _loopModel->iterator();
	while (i.hasNext()) {
		PhStripLoop *loop = i.next();
		if((loop->timeIn() < time) && (loop->timeIn() > previousLoopTime) )
			previousLoopTime = loop->timeIn();
	}

	return previousLoopTime;
}

PhTime PhStripDoc::previousCutTime(PhTime time) const
{
	PhTime previousCutTime = PHTIMEMIN;

	QListIterator<PhStripCut*> i = _cutModel->iterator();
	while(i.hasNext()) {
		PhStripCut *cut = i.next();
		if((cut->timeIn() < time) && (cut->timeIn() > previousCutTime) )
			previousCutTime = cut->timeIn();
	}

	return previousCutTime;
}

PhTime PhStripDoc::previousElementTime(PhTime time) const
{
	PhTime previousElementTime = previousCutTime(time);

	if(previousLoopTime(time) > previousElementTime)
		previousElementTime = previousLoopTime(time);

	if(previousTextTime(time) > previousElementTime)
		previousElementTime = previousTextTime(time);

	return previousElementTime;
}

PhTime PhStripDoc::nextTextTime(PhTime time) const
{
	PhTime nextTextTime = PHTIMEMAX;

	QListIterator<PhStripLine*> i = _lineModel->iterator();
	while (i.hasNext()) {
		PhStripLine *line = i.next();
		PhTime timeIn = line->timeIn();
		if((timeIn > time) && (timeIn < nextTextTime) ) {
			nextTextTime = timeIn;
		}

		QListIterator<PhStripText*> j = line->textModel()->iterator();
		while(j.hasNext()) {
			PhStripText *text = j.next();
			timeIn += text->duration();
			if((timeIn > time) && (timeIn < nextTextTime) ) {
				nextTextTime = timeIn;
			}
		}

		QListIterator<PhStripDetect *> k = line->detectModel()->iterator();
		while(k.hasNext()) {
			PhStripDetect *detect = k.next();
			PhTime detectTime = line->timeIn() + detect->relativeTime();
			if((detectTime > time) && (detectTime < nextTextTime) ) {
				nextTextTime = detectTime;
			}
		}
	}

	return nextTextTime;
}

PhTime PhStripDoc::nextLoopTime(PhTime time) const
{
	PhTime nextLoopTime = PHTIMEMAX;

	QListIterator<PhStripLoop*> i = _loopModel->iterator();
	while (i.hasNext()) {
		PhStripLoop *loop = i.next();
		if((loop->timeIn() > time) && (loop->timeIn() < nextLoopTime) )
			nextLoopTime = loop->timeIn();
		else if(loop->timeIn() > nextLoopTime)
			return nextLoopTime;
	}

	return nextLoopTime;
}

PhTime PhStripDoc::nextCutTime(PhTime time) const
{
	PhTime nextCutTime = PHTIMEMAX;

	QListIterator<PhStripCut*> i = _cutModel->iterator();
	while(i.hasNext()) {
		PhStripCut *cut = i.next();
		if((cut->timeIn() > time) && (cut->timeIn() < nextCutTime) )
			nextCutTime = cut->timeIn();
		else if(cut->timeIn() > nextCutTime)
			return nextCutTime;
	}

	return nextCutTime;
}

PhTime PhStripDoc::nextElementTime(PhTime time) const
{
	PhTime nextElementTime = nextCutTime(time);

	if(nextLoopTime(time) < nextElementTime)
		nextElementTime = nextLoopTime(time);

	if(nextTextTime(time) < nextElementTime)
		nextElementTime = nextTextTime(time);

	return nextElementTime;
}

PhTime PhStripDoc::timeIn() const
{
	return _timeIn;
}

PhTime PhStripDoc::timeOut() const
{
	return _timeOut;
}

PhStripLoop *PhStripDoc::nextLoop(PhTime time) const
{
	QListIterator<PhStripLoop*> i = _loopModel->iterator();
	while (i.hasNext()) {
		PhStripLoop *loop = i.next();
		if(loop->timeIn() > time)
			return loop;
	}

	return NULL;
}

PhStripLoop *PhStripDoc::previousLoop(PhTime time) const
{
	PhTime previousLoopTime = PHTIMEMIN;
	PhStripLoop *previousLoop = NULL;

	QListIterator<PhStripLoop*> i = _loopModel->iterator();
	while (i.hasNext()) {
		PhStripLoop *loop = i.next();
		if((loop->timeIn() < time) && (loop->timeIn() > previousLoopTime) ) {
			previousLoopTime = loop->timeIn();
			previousLoop = loop;
		}
	}

	return previousLoop;
}

QString PhStripDoc::filePath()
{
	return _filePath;
}

QString PhStripDoc::videoFilePath()
{
	return _videoPath;
}

const QList<QString> PhStripDoc::metaKeys()
{
	return _metaInformation.keys();
}

QString PhStripDoc::metaInformation(QString key)
{
	return _metaInformation[key];
}

QString PhStripDoc::title()
{
	return _title;
}

QString PhStripDoc::fullTitle()
{
	QString fullTitle = title();
	if(episode().length() > 0)
		fullTitle += " #" + episode();
	return fullTitle;
}

QString PhStripDoc::translatedTitle()
{
	return _translatedTitle;
}

QString PhStripDoc::episode()
{
	return _episode;
}

QString PhStripDoc::season()
{
	return _season;
}

PhTimeCodeType PhStripDoc::videoTimeCodeType()
{
	return _videoTimeCodeType;
}

PhTime PhStripDoc::videoTimeIn()
{
	return _videoTimeIn;
}

PhTime PhStripDoc::videoFrameIn()
{
	return _videoTimeIn / PhTimeCode::timePerFrame(_videoTimeCodeType);
}

PhTime PhStripDoc::lastTime() const
{
	return _lastTime;
}

void PhStripDoc::setForceRatio169(bool forceRatio)
{
	_videoForceRatio169 = forceRatio;
}

bool PhStripDoc::forceRatio169() const
{
	return _videoForceRatio169;
}

PhStripLineModel *PhStripDoc::lineModel()
{
	return _lineModel;
}

void PhStripDoc::setTitle(QString title)
{
	_title = title;
}

void PhStripDoc::setVideoFilePath(QString filePath)
{
	_videoPath = filePath;
}

void PhStripDoc::setVideoTimeIn(PhTime timeIn, PhTimeCodeType tcType)
{
	_videoTimeIn = timeIn;
	_videoTimeCodeType = tcType;
}

